import{_ as e,c as i,a as l,o as s}from"./app-vAERMEX6.js";const n={};function t(r,a){return s(),i("div",null,a[0]||(a[0]=[l('<h1 id="dgim算法小结" tabindex="-1"><a class="header-anchor" href="#dgim算法小结"><span>DGIM算法小结</span></a></h1><h1 id="_1-要解决的问题" tabindex="-1"><a class="header-anchor" href="#_1-要解决的问题"><span>1 要解决的问题</span></a></h1><p>对于二进制数据流S，设置一个滑动窗口N，统计N中最后k位中1的数目 问题：</p><ul><li>S非常大，不可能放在内存中计算</li><li>N非常大，以至于二进制数据流的 最后N位无法在内存中(甚至无法在硬 盘中)存放</li></ul><h1 id="_2-算法原理" tabindex="-1"><a class="header-anchor" href="#_2-算法原理"><span>2 算法原理</span></a></h1><h2 id="_2-1-将窗口划分为多个桶" tabindex="-1"><a class="header-anchor" href="#_2-1-将窗口划分为多个桶"><span>2.1 将窗口划分为多个桶</span></a></h2><ul><li>每个桶中1的数目必须是2的幂</li><li>从右向左，桶的大小(桶内1的数目)呈指数级增长</li><li>相同大小的桶只能有一到两个 <img src="https://upload-images.jianshu.io/upload_images/7209345-ab15d2f16548b273.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="image.png"></li></ul><h2 id="_2-2-桶的更新过程" tabindex="-1"><a class="header-anchor" href="#_2-2-桶的更新过程"><span>2.2 桶的更新过程</span></a></h2><ol><li>当一个新的数据位到达，检查最左边 桶(最早的桶)。如果该桶最右边位的时间戳已经达到当前时间戳减去N， 那么该桶的所有1不再在窗口之内。删除该桶</li><li>接下来查看新到达的数据位是0，还是1。</li></ol><ul><li>如果是0，则不需要做任何处理</li><li>如果是1 (a). 基于当前时间戳创建一个大小为1的新桶 (b). 如果此时有3个大小为1的桶，将最左边(最 早)的两个大小为1的桶合并为一个大小为2的桶 (c). 如果此时有3个大小为2的桶，将最左边(最早) 的两个大小为2的桶合并为一个大小为4的桶 (d). And so on ... <img src="https://upload-images.jianshu.io/upload_images/7209345-266c30fc8aac99ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="image.png"></li></ul><h2 id="_2-3-查询应答" tabindex="-1"><a class="header-anchor" href="#_2-3-查询应答"><span>2.3 查询应答</span></a></h2><p>估计最近N位中桶1的数目，对最近N位中桶的大小进行求和，减去最左边桶的大小的一半</p><h1 id="_3-算法实现" tabindex="-1"><a class="header-anchor" href="#_3-算法实现"><span>3 算法实现</span></a></h1><p>1）维护一个数据结构：将二进制分组，每组中1的个数是2的次幂，从右至左组的都是非递减的，只须记录每组的两端的位置即可。类似于 等比数列</p><p>2）这样组的个数有O(log(2, N))，记录组的一端位置，所需空间log(2, N)位。则统计整个窗口所占内存为O( (log(2, N)) ^ 2 )</p><p>3）求解：估计1的个数：比较每组两端的位置与k的大小，找到k值所在的组b，累加之前组的大小及组b的一半大小。</p><h1 id="_4-数据结构" tabindex="-1"><a class="header-anchor" href="#_4-数据结构"><span>4 数据结构</span></a></h1><p>每一个新的位进入滑动窗口后，最左边一个位从窗口中移出（同时从桶中移出）；如果最左边的桶的时间戳是当前时间戳减去N（也就是说桶里已经没有处于窗口中的位），则放弃这个桶；对于新加入的位，如果其为0，则无操作；否则建立一个包含新加入位的大小为1的桶；由于新增一个大小为1的桶而出现3个桶大小为1，则合并最左边的两个桶为一个大小为2的桶；合并之后可能出现3个大小为2的桶，则合并最左边两个大小为2的桶得到一个大小为4的桶……依次类推直到到达最左边的桶</p><p>参考链接：https://www.zhihu.com/question/37511567/answer/154056206</p>',19)]))}const o=e(n,[["render",t],["__file","3.html.vue"]]),p=JSON.parse('{"path":"/blogs/js/3.html","title":"DGIM算法小结","lang":"en-US","frontmatter":{"title":"DGIM算法小结","date":"2021/11/23","tags":["算法"],"categories":["算法"]},"headers":[{"level":2,"title":"2.1 将窗口划分为多个桶","slug":"_2-1-将窗口划分为多个桶","link":"#_2-1-将窗口划分为多个桶","children":[]},{"level":2,"title":"2.2 桶的更新过程","slug":"_2-2-桶的更新过程","link":"#_2-2-桶的更新过程","children":[]},{"level":2,"title":"2.3 查询应答","slug":"_2-3-查询应答","link":"#_2-3-查询应答","children":[]}],"git":{"createdTime":1700040736000,"updatedTime":1701862851000,"contributors":[{"name":"liqiu03","email":"liqiu03@baidu.com","commits":2}]},"filePathRelative":"blogs/js/3.md"}');export{o as comp,p as data};
